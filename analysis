package com.example.analyzer;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class DocumentationService {

    @Autowired
    private ApplicationContext applicationContext;

    private final ObjectMapper objectMapper = new ObjectMapper();

    public String generateDocumentation() throws IOException {
        StringBuilder documentation = new StringBuilder();

        analyzeControllers(documentation);
        analyzeRepositories(documentation);
        analyzeFeignClients(documentation);

        return documentation.toString();
    }

    private void analyzeControllers(StringBuilder documentation) {
        Map<String, Object> controllers = applicationContext.getBeansWithAnnotation(RestController.class);

        documentation.append("### Controllers:\n");
        for (Object controller : controllers.values()) {
            Class<?> controllerClass = controller.getClass();
            documentation.append("Controller: ").append(controllerClass.getName()).append("\n");
            Method[] methods = controllerClass.getDeclaredMethods();
            for (Method method : methods) {
                Annotation[] annotations = method.getDeclaredAnnotations();
                for (Annotation annotation : annotations) {
                    if (annotation instanceof RequestMapping) {
                        RequestMapping requestMapping = (RequestMapping) annotation;
                        writeMappingInfo(documentation, method, requestMapping.method(), requestMapping.value());
                    } else if (annotation instanceof GetMapping) {
                        GetMapping getMapping = (GetMapping) annotation;
                        writeMappingInfo(documentation, method, RequestMethod.GET, getMapping.value());
                    } else if (annotation instanceof PostMapping) {
                        PostMapping postMapping = (PostMapping) annotation;
                        writeMappingInfo(documentation, method, RequestMethod.POST, postMapping.value());
                    } else if (annotation instanceof PutMapping) {
                        PutMapping putMapping = (PutMapping) annotation;
                        writeMappingInfo(documentation, method, RequestMethod.PUT, putMapping.value());
                    } else if (annotation instanceof DeleteMapping) {
                        DeleteMapping deleteMapping = (DeleteMapping) annotation;
                        writeMappingInfo(documentation, method, RequestMethod.DELETE, deleteMapping.value());
                    }
                }
            }
            documentation.append("\n");
        }
    }

    private void writeMappingInfo(StringBuilder documentation, Method method, RequestMethod[] methods, String[] values) {
        for (RequestMethod requestMethod : methods) {
            for (String value : values) {
                documentation.append("\t").append(requestMethod).append(" ").append(value).append(" -> ").append(method.getName()).append("\n");
            }
        }
    }

    private void writeMappingInfo(StringBuilder documentation, Method method, RequestMethod requestMethod, String[] values) {
        for (String value : values) {
            documentation.append("\t").append(requestMethod).append(" ").append(value).append(" -> ").append(method.getName()).append("\n");
        }
    }

    private void analyzeRepositories(StringBuilder documentation) throws IOException {
        Map<String, Object> repositories = applicationContext.getBeansWithAnnotation(Repository.class);

        documentation.append("### Repositories:\n");
        for (Object repository : repositories.values()) {
            Class<?> repositoryClass = repository.getClass();
            documentation.append("Repository: ").append(repositoryClass.getName()).append("\n");
            Method[] methods = repositoryClass.getDeclaredMethods();
            for (Method method : methods) {
                documentation.append("\tMethod: ").append(method.getName()).append(" - Operation: ").append(inferDatabaseOperation(method.getName())).append("\n");
                if (method.getReturnType() != void.class) {
                    String responseJson = generateJsonSchema(method.getGenericReturnType());
                    documentation.append("\tResponse JSON: ").append(responseJson).append("\n");
                }
            }
            documentation.append("\n");
        }
    }

    private String inferDatabaseOperation(String methodName) {
        if (methodName.startsWith("find") || methodName.startsWith("get") || methodName.startsWith("read")) {
            return "READ";
        } else if (methodName.startsWith("save") || methodName.startsWith("insert") || methodName.startsWith("update")) {
            return "WRITE";
        } else if (methodName.startsWith("delete") || methodName.startsWith("remove")) {
            return "DELETE";
        }
        return "UNKNOWN";
    }

    private void analyzeFeignClients(StringBuilder documentation) throws IOException {
        // Find all classes ending with "Client"
        Set<Class<?>> feignClientClasses = applicationContext.getBeansOfType(Object.class).values().stream()
                .map(Object::getClass)
                .filter(clazz -> clazz.getSimpleName().endsWith("Client"))
                .collect(Collectors.toSet());

        documentation.append("### Feign Clients:\n");
        for (Class<?> feignClientClass : feignClientClasses) {
            documentation.append("Feign Client: ").append(feignClientClass.getName()).append("\n");
            Method[] methods = feignClientClass.getDeclaredMethods();
            for (Method method : methods) {
                documentation.append("\tMethod: ").append(method.getName()).append(" - HTTP Method: ").append(inferHttpMethod(method)).append("\n");
                String requestJson = generateJsonSchema(getFirstParameterType(method));
                String responseJson = generateJsonSchema(method.getGenericReturnType());
                documentation.append("\tRequest JSON: ").append(requestJson).append("\n");
                documentation.append("\tResponse JSON: ").append(responseJson).append("\n");
            }
            documentation.append("\n");
        }
    }

    private String inferHttpMethod(Method method) {
        // This implementation might vary based on how you define HTTP methods in your manually created Feign clients.
        // Adjust this part according to your specific implementation.
        // For simplicity, we assume GET for demonstration.
        return "GET";
    }

    private Type getFirstParameterType(Method method) {
        return method.getGenericParameterTypes().length > 0 ? method.getGenericParameterTypes()[0] : null;
    }

    private String generateJsonSchema(Type type) {
        if (type == null) return "{}";
        try {
            Object instance = createInstance(type);
            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(instance);
        } catch (Exception e) {
            return "{}";
        }
    }

    private Object createInstance(Type type) throws Exception {
        if (type instanceof Class) {
            return ((Class<?>) type).getDeclaredConstructor().newInstance();
        } else if (type instanceof ParameterizedType) {
            return ((Class<?>) ((ParameterizedType) type).getRawType()).getDeclaredConstructor().newInstance();
        }
        return new Object();
    }
}

